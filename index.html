<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js using Havok</title>

    <!-- Babylon.js 
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    -->

    <script src="/node_modules/@babylonjs/havok/lib/umd/HavokPhysics_umd.js"></script>
    <script src="/node_modules/babylonjs/babylon.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #canvasZone {
        width: 100%;
        height: 100%;
      }


      #shotButton {        
        position: absolute; 
        bottom: 100px; 
        width: 100%; 
        z-index:9999;
        height: 100px; 
        width: 100px; 
        left:calc(50% - 50px);
        border-radius: 50px;
        border: 3px solid #FFF;
        display:block;
      }
    </style>
  </head>
  <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <a href="javascript:void(0);" id="shotButton">&nbsp;</a>
    <script>
      const game= {
          impulseModifier: 15,
          maxImpulse: 100,
          impulseTime: 0,
          shots: 0
      };
      const canvas = document.getElementById("renderCanvas");
      
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });
      const createScene = async function () {
        // await BABYLON.InitializeCSG2Async(); // needed for CSG2

        // This creates a basic Babylon Scene object (non-mesh)
        const scene = new BABYLON.Scene(engine);

        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;

        const green = new BABYLON.StandardMaterial("groundMat");

        // Color green
        green.diffuseColor = new BABYLON.Color3(0, .8, 0);

        // Our built-in 'sphere' shape.
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 2, segments: 16 }, scene);
        sphere.position.y = 1;

        // Create a camera locked to sphere
        const camera = new BABYLON.ArcRotateCamera("camera1", Math.PI/4, Math.PI/4, 10, new BABYLON.Vector3(0,0,0));   
        camera.setPosition(new BABYLON.Vector3(0, 120, -80));
        camera.lockedTarget = sphere; //version 2.5 onwards
        // This attaches the camera to the canvas
        camera.attachControl(canvas, true); // Allows mouse control

        // Our built-in 'ground' shape.
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 30 }, scene);
        ground.position.z = 10
        ground.material = green; //Place the material property of the ground

        // Ground with hole using ground subtracted by tube to create a new mesh  
        const tube = BABYLON.MeshBuilder.CreateCylinder("tube", {
          height:4, 
          diameterTop:4, 
          diameterBottom:4, 
          tessellation:16, 
          subdivisions:1
        }, scene);
        tube.position.z = ground.position.z ;

        // use Constructive Solid Geometry to subtract tube from ground
        // @TODO - use CSG2 instead (CSG2 not working-  Error while creating the CSG: Not manifold)
        var groundCSG = BABYLON.CSG.FromMesh(ground);
        var tubeCSG = BABYLON.CSG.FromMesh(tube);
        var hole = groundCSG.subtract(tubeCSG).toMesh("hole", null, scene);
        hole.position = new BABYLON.Vector3(0, 0, 40);
        hole.material = green;
        
        // Remove the tube now that the hole is made
        tube.dispose();

        // Add a trigger at the bottom of the hole to detect intersection with sphere
        const trigger = BABYLON.MeshBuilder.CreateBox("trigger", {height: 1, width:5, depth:5}, scene);
        trigger.position = new BABYLON.Vector3(hole.position.x, -2, hole.position.z);
        trigger.actionManager = new BABYLON.ActionManager(scene);
        trigger.actionManager.registerAction(new BABYLON.ExecuteCodeAction({
              trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger,
              parameter: scene.getMeshByName("sphere"),
          },
          () => {
            setTimeout(() => {
              alert('Hole in ' + game.shots)
            }, "1000");
              
          },
        ));


        // Bumper using a box shape
        const bumper1 = BABYLON.MeshBuilder.CreateBox("bumper1", {height: 5, width:30}, scene);
        bumper1.position.z = -5;
        bumper1.position.y = 2;
        bumper1.material = green;

        const bumper2 = bumper1.clone("bumper2");
        bumper2.position.z = 55;
        bumper2.material = green;

        const bumper3 = BABYLON.MeshBuilder.CreateBox("bumper3", {height: 5, depth:60}, scene);
        bumper3.position.z = 25;
        bumper3.position.y = 2;
        bumper3.position.x = -15;
        bumper3.material = green;

        const bumper4 = bumper3.clone("bumper4");
        bumper4.position.x = 15;
        bumper4.material = green;

        // This targets the camera to scene origin
        //camera.setTarget(BABYLON.Vector3.Zero());
        camera.setTarget(sphere.position);


        // initialize plugin
        const havokInstance = await HavokPhysics();
        // pass the engine to the plugin
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        // enable physics in the scene with a gravity
        scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

        // Create a sphere shape and the associated body. Size will be determined automatically.
        const sphereAggregate = new BABYLON.PhysicsAggregate(sphere, BABYLON.PhysicsShapeType.SPHERE, { mass: 2, restitution: .5, friction:.9 }, scene);

        // Create static box shapes.
        const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0 }, scene);
        const bumper1Aggregate = new BABYLON.PhysicsAggregate(bumper1, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        const bumper2Aggregate = new BABYLON.PhysicsAggregate(bumper2, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        const bumper3Aggregate = new BABYLON.PhysicsAggregate(bumper3, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        const bumper4Aggregate = new BABYLON.PhysicsAggregate(bumper4, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);

        // https://www.babylonjs-playground.com/#T6NP3F#0
        // Create a static mesh shape.
        const holeAggregate = new BABYLON.PhysicsAggregate(hole, BABYLON.PhysicsShapeType.MESH, { mass: 0, restitution: 0 }, scene);

        // Create the UI
        const shotButton = document.getElementById('shotButton');
        var intervalId = 0;

        function getImpulseAmount() {
          let impulseAmount = (new Date() - game.impulseTime) / game.impulseModifier;
          if (impulseAmount > game.maxImpulse) {
            impulseAmount = game.maxImpulse;
          }
          return impulseAmount;
        }
      
        shotButton.addEventListener("mousedown", function() {
          sphereAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
          sphereAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
          game.impulseTime = new Date();
          intervalId = setInterval(() => {
            let impulseAmount = getImpulseAmount();
            console.log(impulseAmount);
            let r = Math.min(255, (255 * (impulseAmount / 50)));
            if (impulseAmount < 33) {
                r = 255 - impulseAmount * 3;
            }
            let g = Math.min(255, (255 * ((100 - impulseAmount) / 60)));
            let b = 255 - impulseAmount * 3;
            
            shotButton.style.borderColor = 'rgb('+r+' '+g+' '+b+')';
          },10);
        });

        shotButton.addEventListener("mouseup", function() {
          clearInterval(intervalId);
          shotButton.style.borderColor = 'white';

          let impulseAmount = getImpulseAmount();
          /*
          // Example of impulse from camera direction
          let impulseDirection = camera.getDirection(direction); // Rotate the direction into the camera's local space
          impulseDirection.y = 0; // Discard the y component
          impulseDirection.normalize(); // Make it of length 1 again
          sphere.applyImpulse(impulseDirection.scale(5), sphere.position);

          */

          let angle  = camera.getDirection(sphere.position);

          angle.y = 0; // Discard the y component
          angle.normalize(); // Make it of length 1 again (why?)


          // console.log(angle)

          let impulse = new BABYLON.Vector3(impulseAmount * angle.x, 0, impulseAmount * angle.z);
          //let impulse = new BABYLON.Vector3(angle.scale(impulseAmount));

          //let impulse = new BABYLON.Vector3(impulseAmount * Math.sin(angle), 0, impulseAmount * Math.cos(angle))
          //let impulse = new BABYLON.Vector3(0, 0, impulseAmount)
          console.log('impulseAmount=' + impulseAmount);


          sphereAggregate.body.applyImpulse(impulse, sphere.getAbsolutePosition());
          game.shots++;
        });
        return scene;
      };

      createScene().then((scene) => {
        engine.runRenderLoop(function () {
          if (scene) {
            scene.render();
          }
        });
      });
      // Resize
      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>