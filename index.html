<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js using Havok</title>

    <!-- Babylon.js 
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    -->

    <script src="/node_modules/@babylonjs/havok/lib/umd/HavokPhysics_umd.js"></script>
    <script src="/node_modules/babylonjs/babylon.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #canvasZone {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
      const game= {
          impulseTime: 0,
          shots: 0
      };
      const canvas = document.getElementById("renderCanvas");
      
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });
      const createScene = async function () {
        // await BABYLON.InitializeCSG2Async(); // needed for CSG2

        // This creates a basic Babylon Scene object (non-mesh)
        const scene = new BABYLON.Scene(engine);



        // This attaches the camera to the canvas
        //camera.attachControl(canvas, true);
        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;

        const green = new BABYLON.StandardMaterial("groundMat");
        // Color green
        green.diffuseColor = new BABYLON.Color3(0, .8, 0);

        // Our built-in 'sphere' shape.
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 2, segments: 16 }, scene);
        sphere.position.y = 1;

        // Create a camera locked to sphere
        const camera = new BABYLON.ArcRotateCamera("camera1", Math.PI/4, Math.PI/4, 10, new BABYLON.Vector3(0,0,0));   
        //camera.cameraRotation = 0;
        //camera.noRotationConstraint = true;
        //camera.heightOffset = 100;
        camera.setPosition(new BABYLON.Vector3(0, 120, -80));
        camera.lockedTarget = sphere; //version 2.5 onwards

        // Our built-in 'ground' shape.
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 30 }, scene);
        ground.position.z = 10
        ground.material = green; //Place the material property of the ground

        // Ground with hole using ground subtracted by tube to create a new mesh  
        const tube = BABYLON.MeshBuilder.CreateCylinder("tube", {
          height:4, 
          diameterTop:4, 
          diameterBottom:4, 
          tessellation:16, 
          subdivisions:1
        }, scene);
        tube.position.z = ground.position.z ;

        // use Constructive Solid Geometry to subtract tube from ground
        // @TODO - use CSG2 instead (CSG2 not working-  Error while creating the CSG: Not manifold)
        var groundCSG = BABYLON.CSG.FromMesh(ground);
        var tubeCSG = BABYLON.CSG.FromMesh(tube);
        var hole = groundCSG.subtract(tubeCSG).toMesh("hole", null, scene);
        hole.position = new BABYLON.Vector3(0, 0, 40);
        hole.material = green;
        
        // Remove the tube now that the hole is made
        tube.dispose();

        // Add a trigger at the bottom of the hole to detect intersection with sphere
        const trigger = BABYLON.MeshBuilder.CreateBox("trigger", {height: 1, width:5, depth:5}, scene);
        trigger.position = new BABYLON.Vector3(hole.position.x, -2, hole.position.z);
        trigger.actionManager = new BABYLON.ActionManager(scene);
        trigger.actionManager.registerAction(new BABYLON.ExecuteCodeAction({
              trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger,
              parameter: scene.getMeshByName("sphere"),
          },
          () => {
              alert('Hole in ' + game.shots)
          },
        ));


        // Bumper using a box shape
        const bumper1 = BABYLON.MeshBuilder.CreateBox("bumper1", {height: 4, width:30}, scene);
        bumper1.position.z = -5;
        bumper1.position.y = 1;

        const bumper2 = bumper1.clone("bumper2");
        bumper2.position.z = 55;

        // This targets the camera to scene origin
        //camera.setTarget(BABYLON.Vector3.Zero());
        camera.setTarget(sphere.position);


        // initialize plugin
        const havokInstance = await HavokPhysics();
        // pass the engine to the plugin
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        // enable physics in the scene with a gravity
        scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

        // Create a sphere shape and the associated body. Size will be determined automatically.
        const sphereAggregate = new BABYLON.PhysicsAggregate(sphere, BABYLON.PhysicsShapeType.SPHERE, { mass: 2, restitution: .5, friction:.5 }, scene);

        // Create a static box shape.
        const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        const bumper1Aggregate = new BABYLON.PhysicsAggregate(bumper1, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        const bumper2Aggregate = new BABYLON.PhysicsAggregate(bumper2, BABYLON.PhysicsShapeType.BOX, { mass: 0, restitution: 0  }, scene);
        // https://www.babylonjs-playground.com/#T6NP3F#0
        // Create a static mesh shape.
        const holeAggregate = new BABYLON.PhysicsAggregate(hole, BABYLON.PhysicsShapeType.MESH, { mass: 0, restitution: 0  }, scene);

        /*
        const tubeAggregate = new BABYLON.PhysicsAggregate(tube, BABYLON.PhysicsShapeType.CONVEX_HULL, {
            mass: 0,
            restitution: 0,
            friction: 0
        }, scene);
        */


        // Pointer input
        scene.onPointerObservable.add((pointerInfo) => {
          switch (pointerInfo.type) {
            case BABYLON.PointerEventTypes.POINTERDOWN:
              game.impulseTime = new Date();
              console.log("POINTER DOWN @ " + pointerInfo.event.clientX + ',' +pointerInfo.event.clientY);
              break;
            case BABYLON.PointerEventTypes.POINTERUP:
              let impulseAmount = (new Date() - game.impulseTime) / 20;
              let impulse = new BABYLON.Vector3(0, 0, impulseAmount)
              console.log('impulseAmount=' + impulseAmount);
              console.log("POINTER UP @ " + pointerInfo.event.clientX + ',' +pointerInfo.event.clientY);
              //sphereAggregate.body.applyImpulse(sphereAggregate.body, {x:0, y:impulseAmount, z:0}, sphere.position);
              sphereAggregate.body.applyImpulse(impulse, sphere.getAbsolutePosition());
              game.shots++;
              break;
          }
        });


        return scene;
      };

      createScene().then((scene) => {
        engine.runRenderLoop(function () {
          if (scene) {
            scene.render();
          }
        });
      });
      // Resize
      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>